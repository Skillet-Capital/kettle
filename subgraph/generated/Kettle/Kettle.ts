// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class LoanOfferTaken extends ethereum.Event {
  get params(): LoanOfferTaken__Params {
    return new LoanOfferTaken__Params(this);
  }
}

export class LoanOfferTaken__Params {
  _event: LoanOfferTaken;

  constructor(event: LoanOfferTaken) {
    this._event = event;
  }

  get offerHash(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get lienId(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get lender(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get borrower(): Address {
    return this._event.parameters[3].value.toAddress();
  }

  get currency(): Address {
    return this._event.parameters[4].value.toAddress();
  }

  get collateralType(): i32 {
    return this._event.parameters[5].value.toI32();
  }

  get collection(): Address {
    return this._event.parameters[6].value.toAddress();
  }

  get tokenId(): BigInt {
    return this._event.parameters[7].value.toBigInt();
  }

  get amount(): BigInt {
    return this._event.parameters[8].value.toBigInt();
  }

  get borrowAmount(): BigInt {
    return this._event.parameters[9].value.toBigInt();
  }

  get rate(): BigInt {
    return this._event.parameters[10].value.toBigInt();
  }

  get duration(): BigInt {
    return this._event.parameters[11].value.toBigInt();
  }

  get startTime(): BigInt {
    return this._event.parameters[12].value.toBigInt();
  }
}

export class NonceIncremented extends ethereum.Event {
  get params(): NonceIncremented__Params {
    return new NonceIncremented__Params(this);
  }
}

export class NonceIncremented__Params {
  _event: NonceIncremented;

  constructor(event: NonceIncremented) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newNonce(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class OfferCancelled extends ethereum.Event {
  get params(): OfferCancelled__Params {
    return new OfferCancelled__Params(this);
  }
}

export class OfferCancelled__Params {
  _event: OfferCancelled;

  constructor(event: OfferCancelled) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get salt(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class OwnershipTransferred extends ethereum.Event {
  get params(): OwnershipTransferred__Params {
    return new OwnershipTransferred__Params(this);
  }
}

export class OwnershipTransferred__Params {
  _event: OwnershipTransferred;

  constructor(event: OwnershipTransferred) {
    this._event = event;
  }

  get previousOwner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newOwner(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class Refinance extends ethereum.Event {
  get params(): Refinance__Params {
    return new Refinance__Params(this);
  }
}

export class Refinance__Params {
  _event: Refinance;

  constructor(event: Refinance) {
    this._event = event;
  }

  get lienId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get collection(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get currency(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get oldLender(): Address {
    return this._event.parameters[4].value.toAddress();
  }

  get newLender(): Address {
    return this._event.parameters[5].value.toAddress();
  }

  get oldBorrowAmount(): BigInt {
    return this._event.parameters[6].value.toBigInt();
  }

  get newBorrowAmount(): BigInt {
    return this._event.parameters[7].value.toBigInt();
  }

  get oldRate(): BigInt {
    return this._event.parameters[8].value.toBigInt();
  }

  get newRate(): BigInt {
    return this._event.parameters[9].value.toBigInt();
  }
}

export class Repay extends ethereum.Event {
  get params(): Repay__Params {
    return new Repay__Params(this);
  }
}

export class Repay__Params {
  _event: Repay;

  constructor(event: Repay) {
    this._event = event;
  }

  get lienId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get collection(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Seize extends ethereum.Event {
  get params(): Seize__Params {
    return new Seize__Params(this);
  }
}

export class Seize__Params {
  _event: Seize;

  constructor(event: Seize) {
    this._event = event;
  }

  get lienId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get collection(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class Kettle__borrowInputOfferStruct extends ethereum.Tuple {
  get lender(): Address {
    return this[0].toAddress();
  }

  get collection(): Address {
    return this[1].toAddress();
  }

  get collateralType(): i32 {
    return this[2].toI32();
  }

  get collateralIdentifier(): BigInt {
    return this[3].toBigInt();
  }

  get collateralAmount(): BigInt {
    return this[4].toBigInt();
  }

  get currency(): Address {
    return this[5].toAddress();
  }

  get totalAmount(): BigInt {
    return this[6].toBigInt();
  }

  get minAmount(): BigInt {
    return this[7].toBigInt();
  }

  get maxAmount(): BigInt {
    return this[8].toBigInt();
  }

  get duration(): BigInt {
    return this[9].toBigInt();
  }

  get rate(): BigInt {
    return this[10].toBigInt();
  }

  get salt(): BigInt {
    return this[11].toBigInt();
  }

  get expiration(): BigInt {
    return this[12].toBigInt();
  }

  get fees(): Array<Kettle__borrowInputOfferFeesStruct> {
    return this[13].toTupleArray<Kettle__borrowInputOfferFeesStruct>();
  }
}

export class Kettle__borrowInputOfferFeesStruct extends ethereum.Tuple {
  get rate(): i32 {
    return this[0].toI32();
  }

  get recipient(): Address {
    return this[1].toAddress();
  }
}

export class Kettle__borrowInputAuthStruct extends ethereum.Tuple {
  get offerHash(): Bytes {
    return this[0].toBytes();
  }

  get taker(): Address {
    return this[1].toAddress();
  }

  get expiration(): BigInt {
    return this[2].toBigInt();
  }

  get collateralHash(): Bytes {
    return this[3].toBytes();
  }
}

export class Kettle__borrowBatchInputLoanOffersStruct extends ethereum.Tuple {
  get offer(): Kettle__borrowBatchInputLoanOffersOfferStruct {
    return changetype<Kettle__borrowBatchInputLoanOffersOfferStruct>(
      this[0].toTuple()
    );
  }

  get offerSignature(): Bytes {
    return this[1].toBytes();
  }
}

export class Kettle__borrowBatchInputLoanOffersOfferStruct extends ethereum.Tuple {
  get lender(): Address {
    return this[0].toAddress();
  }

  get collection(): Address {
    return this[1].toAddress();
  }

  get collateralType(): i32 {
    return this[2].toI32();
  }

  get collateralIdentifier(): BigInt {
    return this[3].toBigInt();
  }

  get collateralAmount(): BigInt {
    return this[4].toBigInt();
  }

  get currency(): Address {
    return this[5].toAddress();
  }

  get totalAmount(): BigInt {
    return this[6].toBigInt();
  }

  get minAmount(): BigInt {
    return this[7].toBigInt();
  }

  get maxAmount(): BigInt {
    return this[8].toBigInt();
  }

  get duration(): BigInt {
    return this[9].toBigInt();
  }

  get rate(): BigInt {
    return this[10].toBigInt();
  }

  get salt(): BigInt {
    return this[11].toBigInt();
  }

  get expiration(): BigInt {
    return this[12].toBigInt();
  }

  get fees(): Array<Kettle__borrowBatchInputLoanOffersOfferFeesStruct> {
    return this[13].toTupleArray<
      Kettle__borrowBatchInputLoanOffersOfferFeesStruct
    >();
  }
}

export class Kettle__borrowBatchInputLoanOffersOfferFeesStruct extends ethereum.Tuple {
  get rate(): i32 {
    return this[0].toI32();
  }

  get recipient(): Address {
    return this[1].toAddress();
  }
}

export class Kettle__borrowBatchInputFullfillmentsStruct extends ethereum.Tuple {
  get offerIndex(): BigInt {
    return this[0].toBigInt();
  }

  get loanAmount(): BigInt {
    return this[1].toBigInt();
  }

  get collateralIdentifier(): BigInt {
    return this[2].toBigInt();
  }

  get auth(): Kettle__borrowBatchInputFullfillmentsAuthStruct {
    return changetype<Kettle__borrowBatchInputFullfillmentsAuthStruct>(
      this[3].toTuple()
    );
  }

  get authSignature(): Bytes {
    return this[4].toBytes();
  }

  get proof(): Array<Bytes> {
    return this[5].toBytesArray();
  }
}

export class Kettle__borrowBatchInputFullfillmentsAuthStruct extends ethereum.Tuple {
  get offerHash(): Bytes {
    return this[0].toBytes();
  }

  get taker(): Address {
    return this[1].toAddress();
  }

  get expiration(): BigInt {
    return this[2].toBigInt();
  }

  get collateralHash(): Bytes {
    return this[3].toBytes();
  }
}

export class Kettle__getBorrowOfferHashInputOfferStruct extends ethereum.Tuple {
  get borrower(): Address {
    return this[0].toAddress();
  }

  get collection(): Address {
    return this[1].toAddress();
  }

  get collateralType(): i32 {
    return this[2].toI32();
  }

  get collateralIdentifier(): BigInt {
    return this[3].toBigInt();
  }

  get collateralAmount(): BigInt {
    return this[4].toBigInt();
  }

  get currency(): Address {
    return this[5].toAddress();
  }

  get loanAmount(): BigInt {
    return this[6].toBigInt();
  }

  get duration(): BigInt {
    return this[7].toBigInt();
  }

  get rate(): BigInt {
    return this[8].toBigInt();
  }

  get salt(): BigInt {
    return this[9].toBigInt();
  }

  get expiration(): BigInt {
    return this[10].toBigInt();
  }

  get fees(): Array<Kettle__getBorrowOfferHashInputOfferFeesStruct> {
    return this[11].toTupleArray<
      Kettle__getBorrowOfferHashInputOfferFeesStruct
    >();
  }
}

export class Kettle__getBorrowOfferHashInputOfferFeesStruct extends ethereum.Tuple {
  get rate(): i32 {
    return this[0].toI32();
  }

  get recipient(): Address {
    return this[1].toAddress();
  }
}

export class Kettle__getLoanOfferHashInputOfferStruct extends ethereum.Tuple {
  get lender(): Address {
    return this[0].toAddress();
  }

  get collection(): Address {
    return this[1].toAddress();
  }

  get collateralType(): i32 {
    return this[2].toI32();
  }

  get collateralIdentifier(): BigInt {
    return this[3].toBigInt();
  }

  get collateralAmount(): BigInt {
    return this[4].toBigInt();
  }

  get currency(): Address {
    return this[5].toAddress();
  }

  get totalAmount(): BigInt {
    return this[6].toBigInt();
  }

  get minAmount(): BigInt {
    return this[7].toBigInt();
  }

  get maxAmount(): BigInt {
    return this[8].toBigInt();
  }

  get duration(): BigInt {
    return this[9].toBigInt();
  }

  get rate(): BigInt {
    return this[10].toBigInt();
  }

  get salt(): BigInt {
    return this[11].toBigInt();
  }

  get expiration(): BigInt {
    return this[12].toBigInt();
  }

  get fees(): Array<Kettle__getLoanOfferHashInputOfferFeesStruct> {
    return this[13].toTupleArray<
      Kettle__getLoanOfferHashInputOfferFeesStruct
    >();
  }
}

export class Kettle__getLoanOfferHashInputOfferFeesStruct extends ethereum.Tuple {
  get rate(): i32 {
    return this[0].toI32();
  }

  get recipient(): Address {
    return this[1].toAddress();
  }
}

export class Kettle__informationResult {
  value0: string;
  value1: Bytes;

  constructor(value0: string, value1: Bytes) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromString(this.value0));
    map.set("value1", ethereum.Value.fromFixedBytes(this.value1));
    return map;
  }

  getVersion(): string {
    return this.value0;
  }

  getDomainSeparator(): Bytes {
    return this.value1;
  }
}

export class Kettle__loanInputOfferStruct extends ethereum.Tuple {
  get borrower(): Address {
    return this[0].toAddress();
  }

  get collection(): Address {
    return this[1].toAddress();
  }

  get collateralType(): i32 {
    return this[2].toI32();
  }

  get collateralIdentifier(): BigInt {
    return this[3].toBigInt();
  }

  get collateralAmount(): BigInt {
    return this[4].toBigInt();
  }

  get currency(): Address {
    return this[5].toAddress();
  }

  get loanAmount(): BigInt {
    return this[6].toBigInt();
  }

  get duration(): BigInt {
    return this[7].toBigInt();
  }

  get rate(): BigInt {
    return this[8].toBigInt();
  }

  get salt(): BigInt {
    return this[9].toBigInt();
  }

  get expiration(): BigInt {
    return this[10].toBigInt();
  }

  get fees(): Array<Kettle__loanInputOfferFeesStruct> {
    return this[11].toTupleArray<Kettle__loanInputOfferFeesStruct>();
  }
}

export class Kettle__loanInputOfferFeesStruct extends ethereum.Tuple {
  get rate(): i32 {
    return this[0].toI32();
  }

  get recipient(): Address {
    return this[1].toAddress();
  }
}

export class Kettle__loanInputAuthStruct extends ethereum.Tuple {
  get offerHash(): Bytes {
    return this[0].toBytes();
  }

  get taker(): Address {
    return this[1].toAddress();
  }

  get expiration(): BigInt {
    return this[2].toBigInt();
  }

  get collateralHash(): Bytes {
    return this[3].toBytes();
  }
}

export class Kettle__loanBatchInputBorrowOffersStruct extends ethereum.Tuple {
  get offer(): Kettle__loanBatchInputBorrowOffersOfferStruct {
    return changetype<Kettle__loanBatchInputBorrowOffersOfferStruct>(
      this[0].toTuple()
    );
  }

  get offerSignature(): Bytes {
    return this[1].toBytes();
  }
}

export class Kettle__loanBatchInputBorrowOffersOfferStruct extends ethereum.Tuple {
  get borrower(): Address {
    return this[0].toAddress();
  }

  get collection(): Address {
    return this[1].toAddress();
  }

  get collateralType(): i32 {
    return this[2].toI32();
  }

  get collateralIdentifier(): BigInt {
    return this[3].toBigInt();
  }

  get collateralAmount(): BigInt {
    return this[4].toBigInt();
  }

  get currency(): Address {
    return this[5].toAddress();
  }

  get loanAmount(): BigInt {
    return this[6].toBigInt();
  }

  get duration(): BigInt {
    return this[7].toBigInt();
  }

  get rate(): BigInt {
    return this[8].toBigInt();
  }

  get salt(): BigInt {
    return this[9].toBigInt();
  }

  get expiration(): BigInt {
    return this[10].toBigInt();
  }

  get fees(): Array<Kettle__loanBatchInputBorrowOffersOfferFeesStruct> {
    return this[11].toTupleArray<
      Kettle__loanBatchInputBorrowOffersOfferFeesStruct
    >();
  }
}

export class Kettle__loanBatchInputBorrowOffersOfferFeesStruct extends ethereum.Tuple {
  get rate(): i32 {
    return this[0].toI32();
  }

  get recipient(): Address {
    return this[1].toAddress();
  }
}

export class Kettle__loanBatchInputFullfillmentsStruct extends ethereum.Tuple {
  get offerIndex(): BigInt {
    return this[0].toBigInt();
  }

  get auth(): Kettle__loanBatchInputFullfillmentsAuthStruct {
    return changetype<Kettle__loanBatchInputFullfillmentsAuthStruct>(
      this[1].toTuple()
    );
  }

  get authSignature(): Bytes {
    return this[2].toBytes();
  }
}

export class Kettle__loanBatchInputFullfillmentsAuthStruct extends ethereum.Tuple {
  get offerHash(): Bytes {
    return this[0].toBytes();
  }

  get taker(): Address {
    return this[1].toAddress();
  }

  get expiration(): BigInt {
    return this[2].toBigInt();
  }

  get collateralHash(): Bytes {
    return this[3].toBytes();
  }
}

export class Kettle extends ethereum.SmartContract {
  static bind(address: Address): Kettle {
    return new Kettle("Kettle", address);
  }

  _AUTH_SIGNER(): Address {
    let result = super.call("_AUTH_SIGNER", "_AUTH_SIGNER():(address)", []);

    return result[0].toAddress();
  }

  try__AUTH_SIGNER(): ethereum.CallResult<Address> {
    let result = super.tryCall("_AUTH_SIGNER", "_AUTH_SIGNER():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  amountTaken(offerHash: Bytes): BigInt {
    let result = super.call("amountTaken", "amountTaken(bytes32):(uint256)", [
      ethereum.Value.fromFixedBytes(offerHash)
    ]);

    return result[0].toBigInt();
  }

  try_amountTaken(offerHash: Bytes): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "amountTaken",
      "amountTaken(bytes32):(uint256)",
      [ethereum.Value.fromFixedBytes(offerHash)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  blockRange(): BigInt {
    let result = super.call("blockRange", "blockRange():(uint256)", []);

    return result[0].toBigInt();
  }

  try_blockRange(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("blockRange", "blockRange():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  borrow(
    offer: Kettle__borrowInputOfferStruct,
    auth: Kettle__borrowInputAuthStruct,
    offerSignature: Bytes,
    authSignature: Bytes,
    loanAmount: BigInt,
    collateralTokenId: BigInt,
    borrower: Address,
    proof: Array<Bytes>
  ): BigInt {
    let result = super.call(
      "borrow",
      "borrow((address,address,uint8,uint256,uint256,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,(uint16,address)[]),(bytes32,address,uint256,bytes32),bytes,bytes,uint256,uint256,address,bytes32[]):(uint256)",
      [
        ethereum.Value.fromTuple(offer),
        ethereum.Value.fromTuple(auth),
        ethereum.Value.fromBytes(offerSignature),
        ethereum.Value.fromBytes(authSignature),
        ethereum.Value.fromUnsignedBigInt(loanAmount),
        ethereum.Value.fromUnsignedBigInt(collateralTokenId),
        ethereum.Value.fromAddress(borrower),
        ethereum.Value.fromFixedBytesArray(proof)
      ]
    );

    return result[0].toBigInt();
  }

  try_borrow(
    offer: Kettle__borrowInputOfferStruct,
    auth: Kettle__borrowInputAuthStruct,
    offerSignature: Bytes,
    authSignature: Bytes,
    loanAmount: BigInt,
    collateralTokenId: BigInt,
    borrower: Address,
    proof: Array<Bytes>
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "borrow",
      "borrow((address,address,uint8,uint256,uint256,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,(uint16,address)[]),(bytes32,address,uint256,bytes32),bytes,bytes,uint256,uint256,address,bytes32[]):(uint256)",
      [
        ethereum.Value.fromTuple(offer),
        ethereum.Value.fromTuple(auth),
        ethereum.Value.fromBytes(offerSignature),
        ethereum.Value.fromBytes(authSignature),
        ethereum.Value.fromUnsignedBigInt(loanAmount),
        ethereum.Value.fromUnsignedBigInt(collateralTokenId),
        ethereum.Value.fromAddress(borrower),
        ethereum.Value.fromFixedBytesArray(proof)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  borrowBatch(
    loanOffers: Array<Kettle__borrowBatchInputLoanOffersStruct>,
    fullfillments: Array<Kettle__borrowBatchInputFullfillmentsStruct>,
    borrower: Address
  ): Array<BigInt> {
    let result = super.call(
      "borrowBatch",
      "borrowBatch(((address,address,uint8,uint256,uint256,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,(uint16,address)[]),bytes)[],(uint256,uint256,uint256,(bytes32,address,uint256,bytes32),bytes,bytes32[])[],address):(uint256[])",
      [
        ethereum.Value.fromTupleArray(loanOffers),
        ethereum.Value.fromTupleArray(fullfillments),
        ethereum.Value.fromAddress(borrower)
      ]
    );

    return result[0].toBigIntArray();
  }

  try_borrowBatch(
    loanOffers: Array<Kettle__borrowBatchInputLoanOffersStruct>,
    fullfillments: Array<Kettle__borrowBatchInputFullfillmentsStruct>,
    borrower: Address
  ): ethereum.CallResult<Array<BigInt>> {
    let result = super.tryCall(
      "borrowBatch",
      "borrowBatch(((address,address,uint8,uint256,uint256,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,(uint16,address)[]),bytes)[],(uint256,uint256,uint256,(bytes32,address,uint256,bytes32),bytes,bytes32[])[],address):(uint256[])",
      [
        ethereum.Value.fromTupleArray(loanOffers),
        ethereum.Value.fromTupleArray(fullfillments),
        ethereum.Value.fromAddress(borrower)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigIntArray());
  }

  cancelledOrFulfilled(param0: Address, param1: BigInt): BigInt {
    let result = super.call(
      "cancelledOrFulfilled",
      "cancelledOrFulfilled(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromUnsignedBigInt(param1)
      ]
    );

    return result[0].toBigInt();
  }

  try_cancelledOrFulfilled(
    param0: Address,
    param1: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "cancelledOrFulfilled",
      "cancelledOrFulfilled(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromUnsignedBigInt(param1)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  escrows(param0: Address): Address {
    let result = super.call("escrows", "escrows(address):(address)", [
      ethereum.Value.fromAddress(param0)
    ]);

    return result[0].toAddress();
  }

  try_escrows(param0: Address): ethereum.CallResult<Address> {
    let result = super.tryCall("escrows", "escrows(address):(address)", [
      ethereum.Value.fromAddress(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getBorrowOfferHash(offer: Kettle__getBorrowOfferHashInputOfferStruct): Bytes {
    let result = super.call(
      "getBorrowOfferHash",
      "getBorrowOfferHash((address,address,uint8,uint256,uint256,address,uint256,uint256,uint256,uint256,uint256,(uint16,address)[])):(bytes32)",
      [ethereum.Value.fromTuple(offer)]
    );

    return result[0].toBytes();
  }

  try_getBorrowOfferHash(
    offer: Kettle__getBorrowOfferHashInputOfferStruct
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "getBorrowOfferHash",
      "getBorrowOfferHash((address,address,uint8,uint256,uint256,address,uint256,uint256,uint256,uint256,uint256,(uint16,address)[])):(bytes32)",
      [ethereum.Value.fromTuple(offer)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  getEscrow(collection: Address): Address {
    let result = super.call("getEscrow", "getEscrow(address):(address)", [
      ethereum.Value.fromAddress(collection)
    ]);

    return result[0].toAddress();
  }

  try_getEscrow(collection: Address): ethereum.CallResult<Address> {
    let result = super.tryCall("getEscrow", "getEscrow(address):(address)", [
      ethereum.Value.fromAddress(collection)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getLoanOfferHash(offer: Kettle__getLoanOfferHashInputOfferStruct): Bytes {
    let result = super.call(
      "getLoanOfferHash",
      "getLoanOfferHash((address,address,uint8,uint256,uint256,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,(uint16,address)[])):(bytes32)",
      [ethereum.Value.fromTuple(offer)]
    );

    return result[0].toBytes();
  }

  try_getLoanOfferHash(
    offer: Kettle__getLoanOfferHashInputOfferStruct
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "getLoanOfferHash",
      "getLoanOfferHash((address,address,uint8,uint256,uint256,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,(uint16,address)[])):(bytes32)",
      [ethereum.Value.fromTuple(offer)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  getRepaymentAmount(
    borrowAmount: BigInt,
    rate: BigInt,
    duration: BigInt
  ): BigInt {
    let result = super.call(
      "getRepaymentAmount",
      "getRepaymentAmount(uint256,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(borrowAmount),
        ethereum.Value.fromUnsignedBigInt(rate),
        ethereum.Value.fromUnsignedBigInt(duration)
      ]
    );

    return result[0].toBigInt();
  }

  try_getRepaymentAmount(
    borrowAmount: BigInt,
    rate: BigInt,
    duration: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getRepaymentAmount",
      "getRepaymentAmount(uint256,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(borrowAmount),
        ethereum.Value.fromUnsignedBigInt(rate),
        ethereum.Value.fromUnsignedBigInt(duration)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  information(): Kettle__informationResult {
    let result = super.call(
      "information",
      "information():(string,bytes32)",
      []
    );

    return new Kettle__informationResult(
      result[0].toString(),
      result[1].toBytes()
    );
  }

  try_information(): ethereum.CallResult<Kettle__informationResult> {
    let result = super.tryCall(
      "information",
      "information():(string,bytes32)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new Kettle__informationResult(value[0].toString(), value[1].toBytes())
    );
  }

  liens(param0: BigInt): Bytes {
    let result = super.call("liens", "liens(uint256):(bytes32)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);

    return result[0].toBytes();
  }

  try_liens(param0: BigInt): ethereum.CallResult<Bytes> {
    let result = super.tryCall("liens", "liens(uint256):(bytes32)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  loan(
    offer: Kettle__loanInputOfferStruct,
    auth: Kettle__loanInputAuthStruct,
    offerSignature: Bytes,
    authSignature: Bytes
  ): BigInt {
    let result = super.call(
      "loan",
      "loan((address,address,uint8,uint256,uint256,address,uint256,uint256,uint256,uint256,uint256,(uint16,address)[]),(bytes32,address,uint256,bytes32),bytes,bytes):(uint256)",
      [
        ethereum.Value.fromTuple(offer),
        ethereum.Value.fromTuple(auth),
        ethereum.Value.fromBytes(offerSignature),
        ethereum.Value.fromBytes(authSignature)
      ]
    );

    return result[0].toBigInt();
  }

  try_loan(
    offer: Kettle__loanInputOfferStruct,
    auth: Kettle__loanInputAuthStruct,
    offerSignature: Bytes,
    authSignature: Bytes
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "loan",
      "loan((address,address,uint8,uint256,uint256,address,uint256,uint256,uint256,uint256,uint256,(uint16,address)[]),(bytes32,address,uint256,bytes32),bytes,bytes):(uint256)",
      [
        ethereum.Value.fromTuple(offer),
        ethereum.Value.fromTuple(auth),
        ethereum.Value.fromBytes(offerSignature),
        ethereum.Value.fromBytes(authSignature)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  loanBatch(
    borrowOffers: Array<Kettle__loanBatchInputBorrowOffersStruct>,
    fullfillments: Array<Kettle__loanBatchInputFullfillmentsStruct>
  ): Array<BigInt> {
    let result = super.call(
      "loanBatch",
      "loanBatch(((address,address,uint8,uint256,uint256,address,uint256,uint256,uint256,uint256,uint256,(uint16,address)[]),bytes)[],(uint256,(bytes32,address,uint256,bytes32),bytes)[]):(uint256[])",
      [
        ethereum.Value.fromTupleArray(borrowOffers),
        ethereum.Value.fromTupleArray(fullfillments)
      ]
    );

    return result[0].toBigIntArray();
  }

  try_loanBatch(
    borrowOffers: Array<Kettle__loanBatchInputBorrowOffersStruct>,
    fullfillments: Array<Kettle__loanBatchInputFullfillmentsStruct>
  ): ethereum.CallResult<Array<BigInt>> {
    let result = super.tryCall(
      "loanBatch",
      "loanBatch(((address,address,uint8,uint256,uint256,address,uint256,uint256,uint256,uint256,uint256,(uint16,address)[]),bytes)[],(uint256,(bytes32,address,uint256,bytes32),bytes)[]):(uint256[])",
      [
        ethereum.Value.fromTupleArray(borrowOffers),
        ethereum.Value.fromTupleArray(fullfillments)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigIntArray());
  }

  nonces(param0: Address): BigInt {
    let result = super.call("nonces", "nonces(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);

    return result[0].toBigInt();
  }

  try_nonces(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("nonces", "nonces(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  onERC1155BatchReceived(
    param0: Address,
    param1: Address,
    param2: Array<BigInt>,
    param3: Array<BigInt>,
    param4: Bytes
  ): Bytes {
    let result = super.call(
      "onERC1155BatchReceived",
      "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes):(bytes4)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromUnsignedBigIntArray(param2),
        ethereum.Value.fromUnsignedBigIntArray(param3),
        ethereum.Value.fromBytes(param4)
      ]
    );

    return result[0].toBytes();
  }

  try_onERC1155BatchReceived(
    param0: Address,
    param1: Address,
    param2: Array<BigInt>,
    param3: Array<BigInt>,
    param4: Bytes
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "onERC1155BatchReceived",
      "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes):(bytes4)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromUnsignedBigIntArray(param2),
        ethereum.Value.fromUnsignedBigIntArray(param3),
        ethereum.Value.fromBytes(param4)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  onERC1155Received(
    param0: Address,
    param1: Address,
    param2: BigInt,
    param3: BigInt,
    param4: Bytes
  ): Bytes {
    let result = super.call(
      "onERC1155Received",
      "onERC1155Received(address,address,uint256,uint256,bytes):(bytes4)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromUnsignedBigInt(param2),
        ethereum.Value.fromUnsignedBigInt(param3),
        ethereum.Value.fromBytes(param4)
      ]
    );

    return result[0].toBytes();
  }

  try_onERC1155Received(
    param0: Address,
    param1: Address,
    param2: BigInt,
    param3: BigInt,
    param4: Bytes
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "onERC1155Received",
      "onERC1155Received(address,address,uint256,uint256,bytes):(bytes4)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromUnsignedBigInt(param2),
        ethereum.Value.fromUnsignedBigInt(param3),
        ethereum.Value.fromBytes(param4)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  onERC721Received(
    param0: Address,
    param1: Address,
    param2: BigInt,
    param3: Bytes
  ): Bytes {
    let result = super.call(
      "onERC721Received",
      "onERC721Received(address,address,uint256,bytes):(bytes4)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromUnsignedBigInt(param2),
        ethereum.Value.fromBytes(param3)
      ]
    );

    return result[0].toBytes();
  }

  try_onERC721Received(
    param0: Address,
    param1: Address,
    param2: BigInt,
    param3: Bytes
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "onERC721Received",
      "onERC721Received(address,address,uint256,bytes):(bytes4)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromUnsignedBigInt(param2),
        ethereum.Value.fromBytes(param3)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  oracles(param0: Address): BigInt {
    let result = super.call("oracles", "oracles(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);

    return result[0].toBigInt();
  }

  try_oracles(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("oracles", "oracles(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  owner(): Address {
    let result = super.call("owner", "owner():(address)", []);

    return result[0].toAddress();
  }

  try_owner(): ethereum.CallResult<Address> {
    let result = super.tryCall("owner", "owner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  supportsInterface(interfaceId: Bytes): boolean {
    let result = super.call(
      "supportsInterface",
      "supportsInterface(bytes4):(bool)",
      [ethereum.Value.fromFixedBytes(interfaceId)]
    );

    return result[0].toBoolean();
  }

  try_supportsInterface(interfaceId: Bytes): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "supportsInterface",
      "supportsInterface(bytes4):(bool)",
      [ethereum.Value.fromFixedBytes(interfaceId)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get authSigner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class BorrowCall extends ethereum.Call {
  get inputs(): BorrowCall__Inputs {
    return new BorrowCall__Inputs(this);
  }

  get outputs(): BorrowCall__Outputs {
    return new BorrowCall__Outputs(this);
  }
}

export class BorrowCall__Inputs {
  _call: BorrowCall;

  constructor(call: BorrowCall) {
    this._call = call;
  }

  get offer(): BorrowCallOfferStruct {
    return changetype<BorrowCallOfferStruct>(
      this._call.inputValues[0].value.toTuple()
    );
  }

  get auth(): BorrowCallAuthStruct {
    return changetype<BorrowCallAuthStruct>(
      this._call.inputValues[1].value.toTuple()
    );
  }

  get offerSignature(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }

  get authSignature(): Bytes {
    return this._call.inputValues[3].value.toBytes();
  }

  get loanAmount(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }

  get collateralTokenId(): BigInt {
    return this._call.inputValues[5].value.toBigInt();
  }

  get borrower(): Address {
    return this._call.inputValues[6].value.toAddress();
  }

  get proof(): Array<Bytes> {
    return this._call.inputValues[7].value.toBytesArray();
  }
}

export class BorrowCall__Outputs {
  _call: BorrowCall;

  constructor(call: BorrowCall) {
    this._call = call;
  }

  get lienId(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class BorrowCallOfferStruct extends ethereum.Tuple {
  get lender(): Address {
    return this[0].toAddress();
  }

  get collection(): Address {
    return this[1].toAddress();
  }

  get collateralType(): i32 {
    return this[2].toI32();
  }

  get collateralIdentifier(): BigInt {
    return this[3].toBigInt();
  }

  get collateralAmount(): BigInt {
    return this[4].toBigInt();
  }

  get currency(): Address {
    return this[5].toAddress();
  }

  get totalAmount(): BigInt {
    return this[6].toBigInt();
  }

  get minAmount(): BigInt {
    return this[7].toBigInt();
  }

  get maxAmount(): BigInt {
    return this[8].toBigInt();
  }

  get duration(): BigInt {
    return this[9].toBigInt();
  }

  get rate(): BigInt {
    return this[10].toBigInt();
  }

  get salt(): BigInt {
    return this[11].toBigInt();
  }

  get expiration(): BigInt {
    return this[12].toBigInt();
  }

  get fees(): Array<BorrowCallOfferFeesStruct> {
    return this[13].toTupleArray<BorrowCallOfferFeesStruct>();
  }
}

export class BorrowCallOfferFeesStruct extends ethereum.Tuple {
  get rate(): i32 {
    return this[0].toI32();
  }

  get recipient(): Address {
    return this[1].toAddress();
  }
}

export class BorrowCallAuthStruct extends ethereum.Tuple {
  get offerHash(): Bytes {
    return this[0].toBytes();
  }

  get taker(): Address {
    return this[1].toAddress();
  }

  get expiration(): BigInt {
    return this[2].toBigInt();
  }

  get collateralHash(): Bytes {
    return this[3].toBytes();
  }
}

export class BorrowBatchCall extends ethereum.Call {
  get inputs(): BorrowBatchCall__Inputs {
    return new BorrowBatchCall__Inputs(this);
  }

  get outputs(): BorrowBatchCall__Outputs {
    return new BorrowBatchCall__Outputs(this);
  }
}

export class BorrowBatchCall__Inputs {
  _call: BorrowBatchCall;

  constructor(call: BorrowBatchCall) {
    this._call = call;
  }

  get loanOffers(): Array<BorrowBatchCallLoanOffersStruct> {
    return this._call.inputValues[0].value.toTupleArray<
      BorrowBatchCallLoanOffersStruct
    >();
  }

  get fullfillments(): Array<BorrowBatchCallFullfillmentsStruct> {
    return this._call.inputValues[1].value.toTupleArray<
      BorrowBatchCallFullfillmentsStruct
    >();
  }

  get borrower(): Address {
    return this._call.inputValues[2].value.toAddress();
  }
}

export class BorrowBatchCall__Outputs {
  _call: BorrowBatchCall;

  constructor(call: BorrowBatchCall) {
    this._call = call;
  }

  get lienIds(): Array<BigInt> {
    return this._call.outputValues[0].value.toBigIntArray();
  }
}

export class BorrowBatchCallLoanOffersStruct extends ethereum.Tuple {
  get offer(): BorrowBatchCallLoanOffersOfferStruct {
    return changetype<BorrowBatchCallLoanOffersOfferStruct>(this[0].toTuple());
  }

  get offerSignature(): Bytes {
    return this[1].toBytes();
  }
}

export class BorrowBatchCallLoanOffersOfferStruct extends ethereum.Tuple {
  get lender(): Address {
    return this[0].toAddress();
  }

  get collection(): Address {
    return this[1].toAddress();
  }

  get collateralType(): i32 {
    return this[2].toI32();
  }

  get collateralIdentifier(): BigInt {
    return this[3].toBigInt();
  }

  get collateralAmount(): BigInt {
    return this[4].toBigInt();
  }

  get currency(): Address {
    return this[5].toAddress();
  }

  get totalAmount(): BigInt {
    return this[6].toBigInt();
  }

  get minAmount(): BigInt {
    return this[7].toBigInt();
  }

  get maxAmount(): BigInt {
    return this[8].toBigInt();
  }

  get duration(): BigInt {
    return this[9].toBigInt();
  }

  get rate(): BigInt {
    return this[10].toBigInt();
  }

  get salt(): BigInt {
    return this[11].toBigInt();
  }

  get expiration(): BigInt {
    return this[12].toBigInt();
  }

  get fees(): Array<BorrowBatchCallLoanOffersOfferFeesStruct> {
    return this[13].toTupleArray<BorrowBatchCallLoanOffersOfferFeesStruct>();
  }
}

export class BorrowBatchCallLoanOffersOfferFeesStruct extends ethereum.Tuple {
  get rate(): i32 {
    return this[0].toI32();
  }

  get recipient(): Address {
    return this[1].toAddress();
  }
}

export class BorrowBatchCallFullfillmentsStruct extends ethereum.Tuple {
  get offerIndex(): BigInt {
    return this[0].toBigInt();
  }

  get loanAmount(): BigInt {
    return this[1].toBigInt();
  }

  get collateralIdentifier(): BigInt {
    return this[2].toBigInt();
  }

  get auth(): BorrowBatchCallFullfillmentsAuthStruct {
    return changetype<BorrowBatchCallFullfillmentsAuthStruct>(
      this[3].toTuple()
    );
  }

  get authSignature(): Bytes {
    return this[4].toBytes();
  }

  get proof(): Array<Bytes> {
    return this[5].toBytesArray();
  }
}

export class BorrowBatchCallFullfillmentsAuthStruct extends ethereum.Tuple {
  get offerHash(): Bytes {
    return this[0].toBytes();
  }

  get taker(): Address {
    return this[1].toAddress();
  }

  get expiration(): BigInt {
    return this[2].toBigInt();
  }

  get collateralHash(): Bytes {
    return this[3].toBytes();
  }
}

export class CancelOfferCall extends ethereum.Call {
  get inputs(): CancelOfferCall__Inputs {
    return new CancelOfferCall__Inputs(this);
  }

  get outputs(): CancelOfferCall__Outputs {
    return new CancelOfferCall__Outputs(this);
  }
}

export class CancelOfferCall__Inputs {
  _call: CancelOfferCall;

  constructor(call: CancelOfferCall) {
    this._call = call;
  }

  get salt(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class CancelOfferCall__Outputs {
  _call: CancelOfferCall;

  constructor(call: CancelOfferCall) {
    this._call = call;
  }
}

export class CancelOffersCall extends ethereum.Call {
  get inputs(): CancelOffersCall__Inputs {
    return new CancelOffersCall__Inputs(this);
  }

  get outputs(): CancelOffersCall__Outputs {
    return new CancelOffersCall__Outputs(this);
  }
}

export class CancelOffersCall__Inputs {
  _call: CancelOffersCall;

  constructor(call: CancelOffersCall) {
    this._call = call;
  }

  get salts(): Array<BigInt> {
    return this._call.inputValues[0].value.toBigIntArray();
  }
}

export class CancelOffersCall__Outputs {
  _call: CancelOffersCall;

  constructor(call: CancelOffersCall) {
    this._call = call;
  }
}

export class IncrementNonceCall extends ethereum.Call {
  get inputs(): IncrementNonceCall__Inputs {
    return new IncrementNonceCall__Inputs(this);
  }

  get outputs(): IncrementNonceCall__Outputs {
    return new IncrementNonceCall__Outputs(this);
  }
}

export class IncrementNonceCall__Inputs {
  _call: IncrementNonceCall;

  constructor(call: IncrementNonceCall) {
    this._call = call;
  }
}

export class IncrementNonceCall__Outputs {
  _call: IncrementNonceCall;

  constructor(call: IncrementNonceCall) {
    this._call = call;
  }
}

export class LoanCall extends ethereum.Call {
  get inputs(): LoanCall__Inputs {
    return new LoanCall__Inputs(this);
  }

  get outputs(): LoanCall__Outputs {
    return new LoanCall__Outputs(this);
  }
}

export class LoanCall__Inputs {
  _call: LoanCall;

  constructor(call: LoanCall) {
    this._call = call;
  }

  get offer(): LoanCallOfferStruct {
    return changetype<LoanCallOfferStruct>(
      this._call.inputValues[0].value.toTuple()
    );
  }

  get auth(): LoanCallAuthStruct {
    return changetype<LoanCallAuthStruct>(
      this._call.inputValues[1].value.toTuple()
    );
  }

  get offerSignature(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }

  get authSignature(): Bytes {
    return this._call.inputValues[3].value.toBytes();
  }
}

export class LoanCall__Outputs {
  _call: LoanCall;

  constructor(call: LoanCall) {
    this._call = call;
  }

  get lienId(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class LoanCallOfferStruct extends ethereum.Tuple {
  get borrower(): Address {
    return this[0].toAddress();
  }

  get collection(): Address {
    return this[1].toAddress();
  }

  get collateralType(): i32 {
    return this[2].toI32();
  }

  get collateralIdentifier(): BigInt {
    return this[3].toBigInt();
  }

  get collateralAmount(): BigInt {
    return this[4].toBigInt();
  }

  get currency(): Address {
    return this[5].toAddress();
  }

  get loanAmount(): BigInt {
    return this[6].toBigInt();
  }

  get duration(): BigInt {
    return this[7].toBigInt();
  }

  get rate(): BigInt {
    return this[8].toBigInt();
  }

  get salt(): BigInt {
    return this[9].toBigInt();
  }

  get expiration(): BigInt {
    return this[10].toBigInt();
  }

  get fees(): Array<LoanCallOfferFeesStruct> {
    return this[11].toTupleArray<LoanCallOfferFeesStruct>();
  }
}

export class LoanCallOfferFeesStruct extends ethereum.Tuple {
  get rate(): i32 {
    return this[0].toI32();
  }

  get recipient(): Address {
    return this[1].toAddress();
  }
}

export class LoanCallAuthStruct extends ethereum.Tuple {
  get offerHash(): Bytes {
    return this[0].toBytes();
  }

  get taker(): Address {
    return this[1].toAddress();
  }

  get expiration(): BigInt {
    return this[2].toBigInt();
  }

  get collateralHash(): Bytes {
    return this[3].toBytes();
  }
}

export class LoanBatchCall extends ethereum.Call {
  get inputs(): LoanBatchCall__Inputs {
    return new LoanBatchCall__Inputs(this);
  }

  get outputs(): LoanBatchCall__Outputs {
    return new LoanBatchCall__Outputs(this);
  }
}

export class LoanBatchCall__Inputs {
  _call: LoanBatchCall;

  constructor(call: LoanBatchCall) {
    this._call = call;
  }

  get borrowOffers(): Array<LoanBatchCallBorrowOffersStruct> {
    return this._call.inputValues[0].value.toTupleArray<
      LoanBatchCallBorrowOffersStruct
    >();
  }

  get fullfillments(): Array<LoanBatchCallFullfillmentsStruct> {
    return this._call.inputValues[1].value.toTupleArray<
      LoanBatchCallFullfillmentsStruct
    >();
  }
}

export class LoanBatchCall__Outputs {
  _call: LoanBatchCall;

  constructor(call: LoanBatchCall) {
    this._call = call;
  }

  get lienIds(): Array<BigInt> {
    return this._call.outputValues[0].value.toBigIntArray();
  }
}

export class LoanBatchCallBorrowOffersStruct extends ethereum.Tuple {
  get offer(): LoanBatchCallBorrowOffersOfferStruct {
    return changetype<LoanBatchCallBorrowOffersOfferStruct>(this[0].toTuple());
  }

  get offerSignature(): Bytes {
    return this[1].toBytes();
  }
}

export class LoanBatchCallBorrowOffersOfferStruct extends ethereum.Tuple {
  get borrower(): Address {
    return this[0].toAddress();
  }

  get collection(): Address {
    return this[1].toAddress();
  }

  get collateralType(): i32 {
    return this[2].toI32();
  }

  get collateralIdentifier(): BigInt {
    return this[3].toBigInt();
  }

  get collateralAmount(): BigInt {
    return this[4].toBigInt();
  }

  get currency(): Address {
    return this[5].toAddress();
  }

  get loanAmount(): BigInt {
    return this[6].toBigInt();
  }

  get duration(): BigInt {
    return this[7].toBigInt();
  }

  get rate(): BigInt {
    return this[8].toBigInt();
  }

  get salt(): BigInt {
    return this[9].toBigInt();
  }

  get expiration(): BigInt {
    return this[10].toBigInt();
  }

  get fees(): Array<LoanBatchCallBorrowOffersOfferFeesStruct> {
    return this[11].toTupleArray<LoanBatchCallBorrowOffersOfferFeesStruct>();
  }
}

export class LoanBatchCallBorrowOffersOfferFeesStruct extends ethereum.Tuple {
  get rate(): i32 {
    return this[0].toI32();
  }

  get recipient(): Address {
    return this[1].toAddress();
  }
}

export class LoanBatchCallFullfillmentsStruct extends ethereum.Tuple {
  get offerIndex(): BigInt {
    return this[0].toBigInt();
  }

  get auth(): LoanBatchCallFullfillmentsAuthStruct {
    return changetype<LoanBatchCallFullfillmentsAuthStruct>(this[1].toTuple());
  }

  get authSignature(): Bytes {
    return this[2].toBytes();
  }
}

export class LoanBatchCallFullfillmentsAuthStruct extends ethereum.Tuple {
  get offerHash(): Bytes {
    return this[0].toBytes();
  }

  get taker(): Address {
    return this[1].toAddress();
  }

  get expiration(): BigInt {
    return this[2].toBigInt();
  }

  get collateralHash(): Bytes {
    return this[3].toBytes();
  }
}

export class OnERC1155BatchReceivedCall extends ethereum.Call {
  get inputs(): OnERC1155BatchReceivedCall__Inputs {
    return new OnERC1155BatchReceivedCall__Inputs(this);
  }

  get outputs(): OnERC1155BatchReceivedCall__Outputs {
    return new OnERC1155BatchReceivedCall__Outputs(this);
  }
}

export class OnERC1155BatchReceivedCall__Inputs {
  _call: OnERC1155BatchReceivedCall;

  constructor(call: OnERC1155BatchReceivedCall) {
    this._call = call;
  }

  get value0(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get value1(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get value2(): Array<BigInt> {
    return this._call.inputValues[2].value.toBigIntArray();
  }

  get value3(): Array<BigInt> {
    return this._call.inputValues[3].value.toBigIntArray();
  }

  get value4(): Bytes {
    return this._call.inputValues[4].value.toBytes();
  }
}

export class OnERC1155BatchReceivedCall__Outputs {
  _call: OnERC1155BatchReceivedCall;

  constructor(call: OnERC1155BatchReceivedCall) {
    this._call = call;
  }

  get value0(): Bytes {
    return this._call.outputValues[0].value.toBytes();
  }
}

export class OnERC1155ReceivedCall extends ethereum.Call {
  get inputs(): OnERC1155ReceivedCall__Inputs {
    return new OnERC1155ReceivedCall__Inputs(this);
  }

  get outputs(): OnERC1155ReceivedCall__Outputs {
    return new OnERC1155ReceivedCall__Outputs(this);
  }
}

export class OnERC1155ReceivedCall__Inputs {
  _call: OnERC1155ReceivedCall;

  constructor(call: OnERC1155ReceivedCall) {
    this._call = call;
  }

  get value0(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get value1(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get value2(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get value3(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get value4(): Bytes {
    return this._call.inputValues[4].value.toBytes();
  }
}

export class OnERC1155ReceivedCall__Outputs {
  _call: OnERC1155ReceivedCall;

  constructor(call: OnERC1155ReceivedCall) {
    this._call = call;
  }

  get value0(): Bytes {
    return this._call.outputValues[0].value.toBytes();
  }
}

export class OnERC721ReceivedCall extends ethereum.Call {
  get inputs(): OnERC721ReceivedCall__Inputs {
    return new OnERC721ReceivedCall__Inputs(this);
  }

  get outputs(): OnERC721ReceivedCall__Outputs {
    return new OnERC721ReceivedCall__Outputs(this);
  }
}

export class OnERC721ReceivedCall__Inputs {
  _call: OnERC721ReceivedCall;

  constructor(call: OnERC721ReceivedCall) {
    this._call = call;
  }

  get value0(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get value1(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get value2(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get value3(): Bytes {
    return this._call.inputValues[3].value.toBytes();
  }
}

export class OnERC721ReceivedCall__Outputs {
  _call: OnERC721ReceivedCall;

  constructor(call: OnERC721ReceivedCall) {
    this._call = call;
  }

  get value0(): Bytes {
    return this._call.outputValues[0].value.toBytes();
  }
}

export class RefinanceCall extends ethereum.Call {
  get inputs(): RefinanceCall__Inputs {
    return new RefinanceCall__Inputs(this);
  }

  get outputs(): RefinanceCall__Outputs {
    return new RefinanceCall__Outputs(this);
  }
}

export class RefinanceCall__Inputs {
  _call: RefinanceCall;

  constructor(call: RefinanceCall) {
    this._call = call;
  }

  get lien(): RefinanceCallLienStruct {
    return changetype<RefinanceCallLienStruct>(
      this._call.inputValues[0].value.toTuple()
    );
  }

  get lienId(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get loanAmount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get offer(): RefinanceCallOfferStruct {
    return changetype<RefinanceCallOfferStruct>(
      this._call.inputValues[3].value.toTuple()
    );
  }

  get auth(): RefinanceCallAuthStruct {
    return changetype<RefinanceCallAuthStruct>(
      this._call.inputValues[4].value.toTuple()
    );
  }

  get offerSignature(): Bytes {
    return this._call.inputValues[5].value.toBytes();
  }

  get authSignature(): Bytes {
    return this._call.inputValues[6].value.toBytes();
  }

  get proof(): Array<Bytes> {
    return this._call.inputValues[7].value.toBytesArray();
  }
}

export class RefinanceCall__Outputs {
  _call: RefinanceCall;

  constructor(call: RefinanceCall) {
    this._call = call;
  }
}

export class RefinanceCallLienStruct extends ethereum.Tuple {
  get lender(): Address {
    return this[0].toAddress();
  }

  get borrower(): Address {
    return this[1].toAddress();
  }

  get collateralType(): i32 {
    return this[2].toI32();
  }

  get collection(): Address {
    return this[3].toAddress();
  }

  get tokenId(): BigInt {
    return this[4].toBigInt();
  }

  get amount(): BigInt {
    return this[5].toBigInt();
  }

  get currency(): Address {
    return this[6].toAddress();
  }

  get borrowAmount(): BigInt {
    return this[7].toBigInt();
  }

  get duration(): BigInt {
    return this[8].toBigInt();
  }

  get rate(): BigInt {
    return this[9].toBigInt();
  }

  get startTime(): BigInt {
    return this[10].toBigInt();
  }
}

export class RefinanceCallOfferStruct extends ethereum.Tuple {
  get lender(): Address {
    return this[0].toAddress();
  }

  get collection(): Address {
    return this[1].toAddress();
  }

  get collateralType(): i32 {
    return this[2].toI32();
  }

  get collateralIdentifier(): BigInt {
    return this[3].toBigInt();
  }

  get collateralAmount(): BigInt {
    return this[4].toBigInt();
  }

  get currency(): Address {
    return this[5].toAddress();
  }

  get totalAmount(): BigInt {
    return this[6].toBigInt();
  }

  get minAmount(): BigInt {
    return this[7].toBigInt();
  }

  get maxAmount(): BigInt {
    return this[8].toBigInt();
  }

  get duration(): BigInt {
    return this[9].toBigInt();
  }

  get rate(): BigInt {
    return this[10].toBigInt();
  }

  get salt(): BigInt {
    return this[11].toBigInt();
  }

  get expiration(): BigInt {
    return this[12].toBigInt();
  }

  get fees(): Array<RefinanceCallOfferFeesStruct> {
    return this[13].toTupleArray<RefinanceCallOfferFeesStruct>();
  }
}

export class RefinanceCallOfferFeesStruct extends ethereum.Tuple {
  get rate(): i32 {
    return this[0].toI32();
  }

  get recipient(): Address {
    return this[1].toAddress();
  }
}

export class RefinanceCallAuthStruct extends ethereum.Tuple {
  get offerHash(): Bytes {
    return this[0].toBytes();
  }

  get taker(): Address {
    return this[1].toAddress();
  }

  get expiration(): BigInt {
    return this[2].toBigInt();
  }

  get collateralHash(): Bytes {
    return this[3].toBytes();
  }
}

export class RefinanceBatchCall extends ethereum.Call {
  get inputs(): RefinanceBatchCall__Inputs {
    return new RefinanceBatchCall__Inputs(this);
  }

  get outputs(): RefinanceBatchCall__Outputs {
    return new RefinanceBatchCall__Outputs(this);
  }
}

export class RefinanceBatchCall__Inputs {
  _call: RefinanceBatchCall;

  constructor(call: RefinanceBatchCall) {
    this._call = call;
  }

  get loanOffers(): Array<RefinanceBatchCallLoanOffersStruct> {
    return this._call.inputValues[0].value.toTupleArray<
      RefinanceBatchCallLoanOffersStruct
    >();
  }

  get fullfillments(): Array<RefinanceBatchCallFullfillmentsStruct> {
    return this._call.inputValues[1].value.toTupleArray<
      RefinanceBatchCallFullfillmentsStruct
    >();
  }
}

export class RefinanceBatchCall__Outputs {
  _call: RefinanceBatchCall;

  constructor(call: RefinanceBatchCall) {
    this._call = call;
  }
}

export class RefinanceBatchCallLoanOffersStruct extends ethereum.Tuple {
  get offer(): RefinanceBatchCallLoanOffersOfferStruct {
    return changetype<RefinanceBatchCallLoanOffersOfferStruct>(
      this[0].toTuple()
    );
  }

  get offerSignature(): Bytes {
    return this[1].toBytes();
  }
}

export class RefinanceBatchCallLoanOffersOfferStruct extends ethereum.Tuple {
  get lender(): Address {
    return this[0].toAddress();
  }

  get collection(): Address {
    return this[1].toAddress();
  }

  get collateralType(): i32 {
    return this[2].toI32();
  }

  get collateralIdentifier(): BigInt {
    return this[3].toBigInt();
  }

  get collateralAmount(): BigInt {
    return this[4].toBigInt();
  }

  get currency(): Address {
    return this[5].toAddress();
  }

  get totalAmount(): BigInt {
    return this[6].toBigInt();
  }

  get minAmount(): BigInt {
    return this[7].toBigInt();
  }

  get maxAmount(): BigInt {
    return this[8].toBigInt();
  }

  get duration(): BigInt {
    return this[9].toBigInt();
  }

  get rate(): BigInt {
    return this[10].toBigInt();
  }

  get salt(): BigInt {
    return this[11].toBigInt();
  }

  get expiration(): BigInt {
    return this[12].toBigInt();
  }

  get fees(): Array<RefinanceBatchCallLoanOffersOfferFeesStruct> {
    return this[13].toTupleArray<RefinanceBatchCallLoanOffersOfferFeesStruct>();
  }
}

export class RefinanceBatchCallLoanOffersOfferFeesStruct extends ethereum.Tuple {
  get rate(): i32 {
    return this[0].toI32();
  }

  get recipient(): Address {
    return this[1].toAddress();
  }
}

export class RefinanceBatchCallFullfillmentsStruct extends ethereum.Tuple {
  get lien(): RefinanceBatchCallFullfillmentsLienStruct {
    return changetype<RefinanceBatchCallFullfillmentsLienStruct>(
      this[0].toTuple()
    );
  }

  get lienId(): BigInt {
    return this[1].toBigInt();
  }

  get offerIndex(): BigInt {
    return this[2].toBigInt();
  }

  get loanAmount(): BigInt {
    return this[3].toBigInt();
  }

  get proof(): Array<Bytes> {
    return this[4].toBytesArray();
  }

  get auth(): RefinanceBatchCallFullfillmentsAuthStruct {
    return changetype<RefinanceBatchCallFullfillmentsAuthStruct>(
      this[5].toTuple()
    );
  }

  get authSignature(): Bytes {
    return this[6].toBytes();
  }
}

export class RefinanceBatchCallFullfillmentsLienStruct extends ethereum.Tuple {
  get lender(): Address {
    return this[0].toAddress();
  }

  get borrower(): Address {
    return this[1].toAddress();
  }

  get collateralType(): i32 {
    return this[2].toI32();
  }

  get collection(): Address {
    return this[3].toAddress();
  }

  get tokenId(): BigInt {
    return this[4].toBigInt();
  }

  get amount(): BigInt {
    return this[5].toBigInt();
  }

  get currency(): Address {
    return this[6].toAddress();
  }

  get borrowAmount(): BigInt {
    return this[7].toBigInt();
  }

  get duration(): BigInt {
    return this[8].toBigInt();
  }

  get rate(): BigInt {
    return this[9].toBigInt();
  }

  get startTime(): BigInt {
    return this[10].toBigInt();
  }
}

export class RefinanceBatchCallFullfillmentsAuthStruct extends ethereum.Tuple {
  get offerHash(): Bytes {
    return this[0].toBytes();
  }

  get taker(): Address {
    return this[1].toAddress();
  }

  get expiration(): BigInt {
    return this[2].toBigInt();
  }

  get collateralHash(): Bytes {
    return this[3].toBytes();
  }
}

export class RenounceOwnershipCall extends ethereum.Call {
  get inputs(): RenounceOwnershipCall__Inputs {
    return new RenounceOwnershipCall__Inputs(this);
  }

  get outputs(): RenounceOwnershipCall__Outputs {
    return new RenounceOwnershipCall__Outputs(this);
  }
}

export class RenounceOwnershipCall__Inputs {
  _call: RenounceOwnershipCall;

  constructor(call: RenounceOwnershipCall) {
    this._call = call;
  }
}

export class RenounceOwnershipCall__Outputs {
  _call: RenounceOwnershipCall;

  constructor(call: RenounceOwnershipCall) {
    this._call = call;
  }
}

export class RepayCall extends ethereum.Call {
  get inputs(): RepayCall__Inputs {
    return new RepayCall__Inputs(this);
  }

  get outputs(): RepayCall__Outputs {
    return new RepayCall__Outputs(this);
  }
}

export class RepayCall__Inputs {
  _call: RepayCall;

  constructor(call: RepayCall) {
    this._call = call;
  }

  get lien(): RepayCallLienStruct {
    return changetype<RepayCallLienStruct>(
      this._call.inputValues[0].value.toTuple()
    );
  }

  get lienId(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class RepayCall__Outputs {
  _call: RepayCall;

  constructor(call: RepayCall) {
    this._call = call;
  }
}

export class RepayCallLienStruct extends ethereum.Tuple {
  get lender(): Address {
    return this[0].toAddress();
  }

  get borrower(): Address {
    return this[1].toAddress();
  }

  get collateralType(): i32 {
    return this[2].toI32();
  }

  get collection(): Address {
    return this[3].toAddress();
  }

  get tokenId(): BigInt {
    return this[4].toBigInt();
  }

  get amount(): BigInt {
    return this[5].toBigInt();
  }

  get currency(): Address {
    return this[6].toAddress();
  }

  get borrowAmount(): BigInt {
    return this[7].toBigInt();
  }

  get duration(): BigInt {
    return this[8].toBigInt();
  }

  get rate(): BigInt {
    return this[9].toBigInt();
  }

  get startTime(): BigInt {
    return this[10].toBigInt();
  }
}

export class RepayBatchCall extends ethereum.Call {
  get inputs(): RepayBatchCall__Inputs {
    return new RepayBatchCall__Inputs(this);
  }

  get outputs(): RepayBatchCall__Outputs {
    return new RepayBatchCall__Outputs(this);
  }
}

export class RepayBatchCall__Inputs {
  _call: RepayBatchCall;

  constructor(call: RepayBatchCall) {
    this._call = call;
  }

  get repayments(): Array<RepayBatchCallRepaymentsStruct> {
    return this._call.inputValues[0].value.toTupleArray<
      RepayBatchCallRepaymentsStruct
    >();
  }
}

export class RepayBatchCall__Outputs {
  _call: RepayBatchCall;

  constructor(call: RepayBatchCall) {
    this._call = call;
  }
}

export class RepayBatchCallRepaymentsStruct extends ethereum.Tuple {
  get lien(): RepayBatchCallRepaymentsLienStruct {
    return changetype<RepayBatchCallRepaymentsLienStruct>(this[0].toTuple());
  }

  get lienId(): BigInt {
    return this[1].toBigInt();
  }
}

export class RepayBatchCallRepaymentsLienStruct extends ethereum.Tuple {
  get lender(): Address {
    return this[0].toAddress();
  }

  get borrower(): Address {
    return this[1].toAddress();
  }

  get collateralType(): i32 {
    return this[2].toI32();
  }

  get collection(): Address {
    return this[3].toAddress();
  }

  get tokenId(): BigInt {
    return this[4].toBigInt();
  }

  get amount(): BigInt {
    return this[5].toBigInt();
  }

  get currency(): Address {
    return this[6].toAddress();
  }

  get borrowAmount(): BigInt {
    return this[7].toBigInt();
  }

  get duration(): BigInt {
    return this[8].toBigInt();
  }

  get rate(): BigInt {
    return this[9].toBigInt();
  }

  get startTime(): BigInt {
    return this[10].toBigInt();
  }
}

export class SeizeCall extends ethereum.Call {
  get inputs(): SeizeCall__Inputs {
    return new SeizeCall__Inputs(this);
  }

  get outputs(): SeizeCall__Outputs {
    return new SeizeCall__Outputs(this);
  }
}

export class SeizeCall__Inputs {
  _call: SeizeCall;

  constructor(call: SeizeCall) {
    this._call = call;
  }

  get lienPointers(): Array<SeizeCallLienPointersStruct> {
    return this._call.inputValues[0].value.toTupleArray<
      SeizeCallLienPointersStruct
    >();
  }
}

export class SeizeCall__Outputs {
  _call: SeizeCall;

  constructor(call: SeizeCall) {
    this._call = call;
  }
}

export class SeizeCallLienPointersStruct extends ethereum.Tuple {
  get lien(): SeizeCallLienPointersLienStruct {
    return changetype<SeizeCallLienPointersLienStruct>(this[0].toTuple());
  }

  get lienId(): BigInt {
    return this[1].toBigInt();
  }
}

export class SeizeCallLienPointersLienStruct extends ethereum.Tuple {
  get lender(): Address {
    return this[0].toAddress();
  }

  get borrower(): Address {
    return this[1].toAddress();
  }

  get collateralType(): i32 {
    return this[2].toI32();
  }

  get collection(): Address {
    return this[3].toAddress();
  }

  get tokenId(): BigInt {
    return this[4].toBigInt();
  }

  get amount(): BigInt {
    return this[5].toBigInt();
  }

  get currency(): Address {
    return this[6].toAddress();
  }

  get borrowAmount(): BigInt {
    return this[7].toBigInt();
  }

  get duration(): BigInt {
    return this[8].toBigInt();
  }

  get rate(): BigInt {
    return this[9].toBigInt();
  }

  get startTime(): BigInt {
    return this[10].toBigInt();
  }
}

export class SetAuthSignerCall extends ethereum.Call {
  get inputs(): SetAuthSignerCall__Inputs {
    return new SetAuthSignerCall__Inputs(this);
  }

  get outputs(): SetAuthSignerCall__Outputs {
    return new SetAuthSignerCall__Outputs(this);
  }
}

export class SetAuthSignerCall__Inputs {
  _call: SetAuthSignerCall;

  constructor(call: SetAuthSignerCall) {
    this._call = call;
  }

  get authSigner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetAuthSignerCall__Outputs {
  _call: SetAuthSignerCall;

  constructor(call: SetAuthSignerCall) {
    this._call = call;
  }
}

export class SetEscrowCall extends ethereum.Call {
  get inputs(): SetEscrowCall__Inputs {
    return new SetEscrowCall__Inputs(this);
  }

  get outputs(): SetEscrowCall__Outputs {
    return new SetEscrowCall__Outputs(this);
  }
}

export class SetEscrowCall__Inputs {
  _call: SetEscrowCall;

  constructor(call: SetEscrowCall) {
    this._call = call;
  }

  get collection(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get escrow(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class SetEscrowCall__Outputs {
  _call: SetEscrowCall;

  constructor(call: SetEscrowCall) {
    this._call = call;
  }
}

export class TransferOwnershipCall extends ethereum.Call {
  get inputs(): TransferOwnershipCall__Inputs {
    return new TransferOwnershipCall__Inputs(this);
  }

  get outputs(): TransferOwnershipCall__Outputs {
    return new TransferOwnershipCall__Outputs(this);
  }
}

export class TransferOwnershipCall__Inputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }

  get newOwner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class TransferOwnershipCall__Outputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }
}
